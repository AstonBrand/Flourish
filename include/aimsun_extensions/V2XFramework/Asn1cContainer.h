/**
  * Copyright TSS 2017
  *
  * Author: Natale Patriciello <natale.patriciello@aimsun.com>
  */
#pragma once

#include <QSharedData>
#include <fstream>
#include <iostream>

#include "Asn1cContainer.h"
#include "constr_TYPE.h"
#include <QtDebug>
#include "V2XFrameworkUtil.h"

struct asn_TYPE_descriptor_s;

/**
 * \ingroup V2XFramework
 * \brief Container class for a type generated by asn.1 C compiler (https://lionet.info/asn1c/blog/)
 *
 * <b> What is ASN.1? </b>
 *
 * ASN.1 stands for Abstract Syntax Notation One. It allows describing complex
 * data structures independently of any particular programming language.
 * The ASN.1 compiler would take these ASN.1 specifications and produce a
 * set of target language (C, C++, Java) files which would contain the native
 * type definitions for these abstractly specified structures, and also generate
 * a code which would perform the conversions of these structures into/from a
 * series of bytes (serialization/deserialization), (presumably, these routines
 * would be useful if the structure is going to be transferred over the network
 * or written to an external media).
 *
 * There are multiple data encodings developed for ASN.1. The most widely used
 * ones are BER (Basic Encoding Rules), CER (Canonical-),
 * DER (Distinguished Encoding Rules), PER (Packed Encoding Rules)
 * and XER (XML Encoding Rules).
 *
 * <b> How Aimsun deal with ASN.1 </b>
 *
 * In Aimsun we make use of the BSD asn.1 C compiler to translate the ASN.1
 * specification into C++-compatible data structures. ASN1CContainer was born
 * to hide the C-functions and structures that follow from this process.
 * This container can be used in junction with QSharedDataPointer to implement
 * a Copy-On-Write semantic. This class is not meant to be used without a
 * container which abstracts the functionalities provided in the following
 * because these can change in future (we can't predict if the output of the
 * asn.1 C compiler will be the same in the future).
 *
 * For an example of usage, please look to the class CAMMessage. It is
 * necessary to initialize the class by setting the type definition created
 * by the ASN.1 compiler (setTypeDef), and if a manual modification to the internal
 * data is needed, it is necessary to call the method initializeEmpty to allocate
 * the internal memory; is not possible to do this initialization
 * in the constructor due to a lack of a custom constructor in the
 * QSharedDataPointer class.
 *
 * <b> How to write a class which uses a type derived from the ASN.1 compiler </b>
 *
 * Let's start with a simple ASN.1 definition:
 *
 * \code{.unparsed}
   MyModule DEFINITIONS ::=
   BEGIN

   MyTypes ::= SEQUENCE {
	 myObjectId OBJECT IDENTIFIER,
	 mySeqOf SEQUENCE OF MyInt,
	 myBitString BIT STRING {
						muxToken(0),
						modemToken(1)
				  }
   }

   MyInt ::= INTEGER (0..65535) END
   \endcode
 *
 * Compiling this definition will generate a lot of files; however, the main
 * type will be a struct MyTypes_t. This type is mean to be enclosed in the
 * class ASN1CContainer:
 * \code
   ...
   private:
	   QSharedDataPointer< ASN1CContainer<MyTypes_t> > m_message;
   ...
   \endcode
 *
 * Let's suppose that the shared pointer m_message is a private member of the
 * class called MyTypeMessage. It is recommended to initialize the
 * variable in the constructors:
 * \code
   #include "MyTypes.h" // Generated by the asn.1 compiler

   MyTypeMessage::MyTypeMessage()
   {
	   m_message = new ASN1CContainer<MyTypes_t> ();
	   m_message->setTypeDef(&asn_DEF_MyTypes);
   }
   \endcode
 * The object asn_DEF_MyTypes is created automatically by the asn.1 compiler,
 * and defined in the main header of the generated files. It is strictly
 * necessary to set the type definition, or the other methods (including
 * the deconstructor and the memory management) will not work.
 *
 * Giving the COW characteristic of the class, in the deconstructor is not
 * possible to delete the class. The object will be automatically deleted
 * when the internal reference count reaches 0; destroying the pointer,
 * done automatically in the MyTypeMessage deconstructor, decrements
 * the reference count.
 * \code
   MyTypeMessage::~MyTypeMessage()
   {
	   // Do not delete m_message;
   }
   \endcode
 *
 * The message can now be automatically built from an XML file, a byte stream,
 * or a byte file through the corresponding from* functions. For instance:
 * \code
   bool MyTypeMessage::FromXML(const char *filename)
   {
	   return m_message->fromXML(filename);
   }
   \endcode
 *
 * To access the data in a read-only way, it is possible to provide to the user
 * a const access to the data contained in the message itself. For writing
 * access, it is possible to provide a non-const access.
 * Please note that any non-const access to the data, if the reference count
 * of the object is greater than 1, will trigger a deep object copy.
 *
 * \code
	const MyTypes_t* MyTypeMessage::constData() const
	{
		return m_message.constData()->constData();
	}

	MyTypes_t* MyTypeMessage::data()
	{
		return m_message.data()->data();
	}
   \endcode
 *
 *
 */
template<typename asn_TYPE>
class ASN1CContainer : public QSharedData
{
public:
	/**
	 * \brief Creating an empty (and invalid) ASN1CContainer
	 *
	 * To validate the object, call setTypeDef.
	 */
	ASN1CContainer();

	/**
	 * \brief Copy another object (deep copy)
	 *
	 * \param other other object
	 */
	ASN1CContainer (const ASN1CContainer &other);

	/**
	  * \brief Deconstructor
	  *
	  * It calls clear() to perform all the required delete operations.
	  */
	~ASN1CContainer ();

	/**
	 * \brief Return a pointer to the ASN.1 structure, allowing reading and editing
	 *setTypeDef
	 * If the internal reference count is greater than 1, it will trigger
	 * a deep copy even in case of a read operation.
	 *
	 * \return Pointer to the generated ASN.1 structure
	 */
	asn_TYPE* data ();

	/**
	 * \brief Return a const pointer to the ASN.1 structure, allowing reading
	 *
	 * It is not possible to edit the structure, thus no deep copy will be
	 * triggered.
	 *
	 * \return Pointer to the generated ASN.1 structure
	 */
	asn_TYPE const * constData () const;

	/**
	 * \brief Allocate the memory for a manual editing of the message
	 */
	void initializeEmpty ();

	/**
	 * \brief Check if the underlying data is valid
	 *
	 * \return True if the data is some valid object
	 */
	bool hasData () const;

	/**
	 * \brief Set the type definition
	 *
	 * The type definition is provided in the generated C files. It is not
	 * possible to embed it in the constructor because the QSharedData
	 * construct does not take any external argument rather than the pointer
	 * itself.
	 *
	 * \param asnDef the generated definition
	 */
	void setTypeDef (asn_TYPE_descriptor_s *asnDef);

	/**
	 * \brief Perform all the required operation to clear the memory
	 *
	 * This actually delete the underlying data structure.
	 */
	void clear ();

	/**
	 * \brief Write the data structure to a XML output
	 * \param output The output
	 * \return True in case of success
	 */
	bool toXML (std::ostream *output) const;
	/**
	 * \brief Write the data structure to a XML file
	 * \param filename The file name
	 * \return True in case of success
	 */
	bool toXML (const char *filename) const;
	/**
	 * \brief Write the data structure to a binary output
	 * \param output The output vector
	 * \return True in case of success
	 */
	bool toDER (std::vector<char> *output) const;
	/**
	 * \brief Write the data structure to a binary file
	 * \param filename The file name
	 * \return True in case of success
	 */
	bool toDER (const char *filename) const;

	/**
	 * \brief Read the data structure from XML input
	 * \param buf The C buffer (for compatibility with the ASN.1 C functions)
	 * \param size The size of the buffer
	 * \return True in case of success
	 */
	bool fromXML(const char *buf, size_t size);
	/**
	 * \brief Read the data structure from an XML file
	 * \param filename The file name
	 * \return True in case of success
	 */
	bool fromXML(const char *filename);

	/**
	 * \brief Read the data structure from binary input
	 * \param buf The C buffer (for compatibility with the ASN.1 C functions)
	 * \param size The size of the buffer
	 * \return True in case of success
	 */
	bool fromBER(const char *buf, size_t size);
	/**
	 * \brief Read the data structure from binary input
	 * \param input The C++ buffer
	 * \return True in case of success
	 */
	bool fromBER(const std::vector<char> &input);
	/**
	 * \brief Read the data structure from a binary file
	 * \param filename The file name
	 * \return True in case of success
	 */
	bool fromBER(const char *filename);

	/**
	 * \brief Print the data to std::cout
	 */
	void toConsole () const;

protected:
	/**
	 * \brief Define a type for the decode functions provided by the C compiler
	 */
	typedef asn_dec_rval_t (*asn_decode) (struct asn_codec_ctx_s *,
		struct asn_TYPE_descriptor_s *,
		void **,	/* Pointer to a target structure's pointer */
		const void *,	/* Data to be decoded */
		size_t 		/* Size of data buffer */
		);

	/**
	 * \brief Define a type from the various from* function defined in this class
	 */
	typedef bool (ASN1CContainer<asn_TYPE>::*fromFn)(const char *buf, size_t size);

	/**
	 * \brief Set the underlying data of this object
	 * \param data A pointer to the real data
	 */
	void setData (asn_TYPE *data);

	/**
	 * \brief Write a buffer to output stream
	 *
	 * To be used in the C compiler functions
	 *
	 * \param buffer The buffer (const char *buf almost in all cases)
	 * \param size The size of the buffer
	 * \param app_key The structure to write into (std::ostream *)
	 * \return 0 if success
	 */
	static int writeBufToOfstream(const void *buffer, size_t size, void *app_key);

	/**
	 * \brief Write a buffer to output vector
	 *
	 * To be used in the C compiler functions
	 *
	 * \param buffer The buffer (const char *buf almost in all cases)
	 * \param size The size of the buffer
	 * \param app_key The structure to write into (std::vector<char> *)
	 * \return 0 if success
	 */
	static int writeBufToVector(const void *buffer, size_t size, void *app_key);

	/**
	 * \brief Read the data from a buffer, using the a specified function for
	 * decoding
	 *
	 * \param buf The buffer
	 * \param size The buffer size
	 * \param decode The function to use (xer_decode or ber_decode)
	 * \return True if success
	 */
	bool fromBuf(const char *buf, size_t size, asn_decode decode);

	/**
	 * \brief Read the data from a file, using the a specified function for
	 * decoding
	 *
	 * \param filename The filename
	 * \param function The function to use (fromXML or fromBER)
	 * \return True if success
	 */
	bool fromFile(const char *filename, fromFn function);

	/**
	 * \brief Write the data to a file
	 * \param filename The filename
	 * \return True if success
	 */
	bool toFile(const char *filename) const;
private:
	asn_TYPE_descriptor_s *m_asnDef; //!< The definition of the template data
	asn_TYPE *m_data; //!< The real data
};

// ---------------------- Implementation ---------------------------------------
template<typename asn_TYPE>
int ASN1CContainer<asn_TYPE>::writeBufToOfstream(const void *buffer, size_t size,
												 void *app_key)
{
	std::ostream *out_fp = reinterpret_cast<std::ostream*> (app_key);
	const char *buf = static_cast<const char*> (buffer);

	Q_ASSERT(out_fp != nullptr);
	Q_ASSERT(buf != nullptr);

	out_fp->write (buf, size);
	return 0;
}

template<typename asn_TYPE>
int ASN1CContainer<asn_TYPE>::writeBufToVector(const void *buffer, size_t size,
											   void *app_key)
{
	std::vector<char> *out_fp = reinterpret_cast< std::vector<char>* > (app_key);
	const char *buf = static_cast<const char*> (buffer);

	Q_ASSERT(out_fp != nullptr);
	Q_ASSERT(buf != nullptr);

	for (size_t i = 0; i < size; ++i)
	{
		out_fp->push_back(buf[i]);
	}

	return 0;
}

template<typename asn_TYPE>
ASN1CContainer<asn_TYPE>::ASN1CContainer() :
	QSharedData(),
	m_asnDef (nullptr),
	m_data(nullptr)
{
	//qInfo() << "Creating an empty asn_TYPE data";
}

template<typename asn_TYPE>
ASN1CContainer<asn_TYPE>::ASN1CContainer (const ASN1CContainer &other) :
	QSharedData (other),
	m_asnDef (other.m_asnDef),
	m_data (nullptr)
{
	qInfo() << "Deep copying asn_TYPE data";
	std::vector<char> temp;
	bool res;
	const char *msg;

	res = other.toDER(&temp);
	if (!res)
	{
		msg = "Cannot convert data to DER";
		goto out;
	}

	res = fromBER(temp);

	if (!res)
	{
		msg = "Cannot convert data from BER";
		goto out;
	}

	return;

out:
	m_data = nullptr;
	qWarning() << msg;
}

template<typename asn_TYPE>
ASN1CContainer<asn_TYPE>::~ASN1CContainer()
{
	clear ();
}

template<typename asn_TYPE>
void ASN1CContainer<asn_TYPE>::setTypeDef(asn_TYPE_descriptor_s *asnDef)
{
	m_asnDef = asnDef;
}

template<typename asn_TYPE>
void ASN1CContainer<asn_TYPE>::clear()
{
	//qInfo() << "Deleting asn_TYPE data " << m_data;
	Q_ASSERT(m_asnDef != 0);
	ASN_STRUCT_FREE(*m_asnDef, m_data);
	m_data = nullptr;
}

template<typename asn_TYPE>
bool ASN1CContainer<asn_TYPE>::hasData() const
{
	return m_data != nullptr;
}

template<typename asn_TYPE>
asn_TYPE* ASN1CContainer<asn_TYPE>::data()
{
	//qInfo() << "Returning a data (copy)";
	return m_data;
}

template<typename asn_TYPE>
asn_TYPE const * ASN1CContainer<asn_TYPE>::constData() const
{
	//qInfo() << "Returning a const data (no copy)";
	return m_data;
}

template<typename asn_TYPE>
void ASN1CContainer<asn_TYPE>::initializeEmpty()
{
	if (hasData()) {
		delete m_data;
	}

	m_data = static_cast<asn_TYPE*>(calloc(1, sizeof(asn_TYPE)));
}

template<typename asn_TYPE>
void ASN1CContainer<asn_TYPE>::setData(asn_TYPE *data)
{
	qInfo() << "Setting a data";
	if (m_data != 0)
	{
		qInfo() << "Deleting old data";
		clear ();
	}
	m_data = data;
}

// --------------------- to [something] ---------------------------------------
template<typename asn_TYPE>
bool ASN1CContainer<asn_TYPE>::toDER(std::vector<char> *output) const
{
	Q_ASSERT(m_asnDef != 0);
	asn_enc_rval_t er;

	if (!hasData())
	{
		return false;
	}

	er = der_encode(m_asnDef, m_data, writeBufToVector, output);

	return (er.encoded != -1);
}

template<typename asn_TYPE>
bool ASN1CContainer<asn_TYPE>::toDER(const char *filename) const
{
	std::ofstream out;
	out.open (filename);

	bool res = toDER(&out);
	out.close();

	return res;
}

template<typename asn_TYPE>
bool ASN1CContainer<asn_TYPE>::toXML(const char *filename) const
{
	std::ofstream out;
	out.open (filename);

	bool res = toXML(&out);
	out.close();

	return res;
}

template<typename asn_TYPE>
bool ASN1CContainer<asn_TYPE>::toXML(std::ostream *output) const
{
	Q_ASSERT(m_asnDef != 0);
	asn_enc_rval_t er;

	if (!hasData())
	{
		return false;
	}

	er = xer_encode(m_asnDef, m_data, XER_F_BASIC, writeBufToOfstream, output);

	return (er.encoded != -1);
}

template<typename asn_TYPE>
void ASN1CContainer<asn_TYPE>::toConsole() const
{
	std::ostream objOstream (std::cout.rdbuf());
	toXML(&objOstream);
}


// ----------------------- From [something]----------------------------------

template<typename asn_TYPE>
bool ASN1CContainer<asn_TYPE>::fromBuf(const char *buf, size_t size,
									   asn_decode decode)
{
	Q_ASSERT(m_asnDef != nullptr);
	asn_dec_rval_t rval;
	asn_TYPE *temp_data = nullptr;
	bool ret = false;

	if (hasData())
	{
		qInfo() << "The next delete is to clear old data:";
		clear();
	}

	rval = decode(0, m_asnDef, (void**)&temp_data, buf, size);

	setData(temp_data);

	if (rval.code != RC_OK) {
		qInfo() << "Failed to read BER, deleting intermediate result";
		clear();
	} else {
		ret = true;
	}

	return ret;
}

template<typename asn_TYPE>
bool ASN1CContainer<asn_TYPE>::fromFile(const char *filename, fromFn function)
{
	std::ifstream in(filename, std::ifstream::ate | std::ifstream::binary);
	std::ifstream::pos_type size = in.tellg();
	char *fbuf;

	if (size > 0) {
		fbuf = new char [size];
	} else {
		return false;
	}

	std::ifstream myFile (filename, std::ios::in | std::ios::binary);
	myFile.read (fbuf, size);
	bool ret = (this->*function)(fbuf, size);
	return ret;
}

template<typename asn_TYPE>
bool ASN1CContainer<asn_TYPE>::fromXML(const char *buf, size_t size)
{
	return fromBuf(buf, size, xer_decode);
}

template<typename asn_TYPE>
bool ASN1CContainer<asn_TYPE>::fromXML(const char *filename)
{
	return fromFile(filename, &ASN1CContainer<asn_TYPE>::fromXML);
}

template<typename asn_TYPE>
bool ASN1CContainer<asn_TYPE>::fromBER(const char *buf, size_t size)
{
	return fromBuf(buf, size, ber_decode);
}

template<typename asn_TYPE>
bool ASN1CContainer<asn_TYPE>::fromBER(const std::vector<char> &input)
{
	return fromBER(input.data(), input.size());
}

template<typename asn_TYPE>
bool ASN1CContainer<asn_TYPE>::fromBER(const char *filename)
{
	return fromFile(filename, &ASN1CContainer<asn_TYPE>::fromBER);
}
