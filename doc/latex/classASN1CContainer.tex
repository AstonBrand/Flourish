\hypertarget{classASN1CContainer}{}\section{A\+S\+N1\+C\+Container$<$ asn\+\_\+\+T\+Y\+PE $>$ Class Template Reference}
\label{classASN1CContainer}\index{A\+S\+N1\+C\+Container$<$ asn\+\_\+\+T\+Y\+P\+E $>$@{A\+S\+N1\+C\+Container$<$ asn\+\_\+\+T\+Y\+P\+E $>$}}


Container class for a type generated by asn.\+1 C compiler (\href{https://lionet.info/asn1c/blog/}{\tt https\+://lionet.\+info/asn1c/blog/})  




{\ttfamily \#include $<$Asn1c\+Container.\+h$>$}



Inheritance diagram for A\+S\+N1\+C\+Container$<$ asn\+\_\+\+T\+Y\+PE $>$\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=197pt]{classASN1CContainer__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for A\+S\+N1\+C\+Container$<$ asn\+\_\+\+T\+Y\+PE $>$\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=197pt]{classASN1CContainer__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classASN1CContainer_ad8d69cd8ce21023ea36410113162a008}{A\+S\+N1\+C\+Container} ()
\begin{DoxyCompactList}\small\item\em Creating an empty (and invalid) \hyperlink{classASN1CContainer}{A\+S\+N1\+C\+Container}. \end{DoxyCompactList}\item 
\hyperlink{classASN1CContainer_a0fdf5aaaef51b6b9c1e10442e6e72890}{A\+S\+N1\+C\+Container} (const \hyperlink{classASN1CContainer}{A\+S\+N1\+C\+Container} \&other)
\begin{DoxyCompactList}\small\item\em Copy another object (deep copy) \end{DoxyCompactList}\item 
\hyperlink{classASN1CContainer_a26020bb451f75d62ae28bc43568aee17}{$\sim$\+A\+S\+N1\+C\+Container} ()
\begin{DoxyCompactList}\small\item\em Deconstructor. \end{DoxyCompactList}\item 
asn\+\_\+\+T\+Y\+PE $\ast$ \hyperlink{classASN1CContainer_a025329e80ae2a3216fc1d1cf6a8f957d}{data} ()
\begin{DoxyCompactList}\small\item\em Return a pointer to the A\+S\+N.\+1 structure, allowing reading and editing. \end{DoxyCompactList}\item 
asn\+\_\+\+T\+Y\+PE const $\ast$ \hyperlink{classASN1CContainer_a7db5e6ea01cfc7dc209b73788a034b81}{const\+Data} () const 
\begin{DoxyCompactList}\small\item\em Return a const pointer to the A\+S\+N.\+1 structure, allowing reading. \end{DoxyCompactList}\item 
void \hyperlink{classASN1CContainer_a7c7691789087f204c37207590eaaf89d}{initialize\+Empty} ()\hypertarget{classASN1CContainer_a7c7691789087f204c37207590eaaf89d}{}\label{classASN1CContainer_a7c7691789087f204c37207590eaaf89d}

\begin{DoxyCompactList}\small\item\em Allocate the memory for a manual editing of the message. \end{DoxyCompactList}\item 
bool \hyperlink{classASN1CContainer_a67a086c665ecbf7a54e390c8fb7df47f}{has\+Data} () const 
\begin{DoxyCompactList}\small\item\em Check if the underlying data is valid. \end{DoxyCompactList}\item 
void \hyperlink{classASN1CContainer_a61559655caab168362a30c0538950ba3}{set\+Type\+Def} (\hyperlink{structasn__TYPE__descriptor__s}{asn\+\_\+\+T\+Y\+P\+E\+\_\+descriptor\+\_\+s} $\ast$asn\+Def)
\begin{DoxyCompactList}\small\item\em Set the type definition. \end{DoxyCompactList}\item 
void \hyperlink{classASN1CContainer_a6492cd5793ca9e2ab073445b358a68b5}{clear} ()
\begin{DoxyCompactList}\small\item\em Perform all the required operation to clear the memory. \end{DoxyCompactList}\item 
bool \hyperlink{classASN1CContainer_ae444a9554d1a856d74a942f70a3b2fb8}{to\+X\+ML} (std\+::ostream $\ast$output) const 
\begin{DoxyCompactList}\small\item\em Write the data structure to a X\+ML output. \end{DoxyCompactList}\item 
bool \hyperlink{classASN1CContainer_a165c57c9a77d80d5f8cd6c2d6b902650}{to\+X\+ML} (const char $\ast$filename) const 
\begin{DoxyCompactList}\small\item\em Write the data structure to a X\+ML file. \end{DoxyCompactList}\item 
bool \hyperlink{classASN1CContainer_af84be317f31518978a63621b4fc67c40}{to\+D\+ER} (std\+::vector$<$ char $>$ $\ast$output) const 
\begin{DoxyCompactList}\small\item\em Write the data structure to a binary output. \end{DoxyCompactList}\item 
bool \hyperlink{classASN1CContainer_ae3fa0fbad6b0375b36a73be41f2e8075}{to\+D\+ER} (const char $\ast$filename) const 
\begin{DoxyCompactList}\small\item\em Write the data structure to a binary file. \end{DoxyCompactList}\item 
bool \hyperlink{classASN1CContainer_aac98fb872b823dfaffce36a8bf24ddbe}{from\+X\+ML} (const char $\ast$buf, size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Read the data structure from X\+ML input. \end{DoxyCompactList}\item 
bool \hyperlink{classASN1CContainer_af43531162a367d3b79be39e90ec72ebb}{from\+X\+ML} (const char $\ast$filename)
\begin{DoxyCompactList}\small\item\em Read the data structure from an X\+ML file. \end{DoxyCompactList}\item 
bool \hyperlink{classASN1CContainer_a08fc60e1d78b99b33a19dba1f1c39900}{from\+B\+ER} (const char $\ast$buf, size\+\_\+t size)
\begin{DoxyCompactList}\small\item\em Read the data structure from binary input. \end{DoxyCompactList}\item 
bool \hyperlink{classASN1CContainer_afbeda1aa393679759574f17e34cedf06}{from\+B\+ER} (const std\+::vector$<$ char $>$ \&input)
\begin{DoxyCompactList}\small\item\em Read the data structure from binary input. \end{DoxyCompactList}\item 
bool \hyperlink{classASN1CContainer_a7465eb755c1031b3745796faa02781ad}{from\+B\+ER} (const char $\ast$filename)
\begin{DoxyCompactList}\small\item\em Read the data structure from a binary file. \end{DoxyCompactList}\item 
void \hyperlink{classASN1CContainer_acc5d252d15af64426472504f04f2b1e8}{to\+Console} () const \hypertarget{classASN1CContainer_acc5d252d15af64426472504f04f2b1e8}{}\label{classASN1CContainer_acc5d252d15af64426472504f04f2b1e8}

\begin{DoxyCompactList}\small\item\em Print the data to std\+::cout. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Types}
\begin{DoxyCompactItemize}
\item 
typedef \hyperlink{structasn__dec__rval__s}{asn\+\_\+dec\+\_\+rval\+\_\+t}($\ast$ \hyperlink{classASN1CContainer_a9edaf11eed4f5ded9a32200e43832e72}{asn\+\_\+decode}) (struct \hyperlink{structasn__codec__ctx__s}{asn\+\_\+codec\+\_\+ctx\+\_\+s} $\ast$, struct \hyperlink{structasn__TYPE__descriptor__s}{asn\+\_\+\+T\+Y\+P\+E\+\_\+descriptor\+\_\+s} $\ast$, void $\ast$$\ast$, const void $\ast$, size\+\_\+t)\hypertarget{classASN1CContainer_a9edaf11eed4f5ded9a32200e43832e72}{}\label{classASN1CContainer_a9edaf11eed4f5ded9a32200e43832e72}

\begin{DoxyCompactList}\small\item\em Define a type for the decode functions provided by the C compiler. \end{DoxyCompactList}\item 
typedef bool(\hyperlink{classASN1CContainer}{A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::$\ast$ \hyperlink{classASN1CContainer_a5830db096eef3cee08cb7e948624aa3c}{from\+Fn}) (const char $\ast$buf, size\+\_\+t size)\hypertarget{classASN1CContainer_a5830db096eef3cee08cb7e948624aa3c}{}\label{classASN1CContainer_a5830db096eef3cee08cb7e948624aa3c}

\begin{DoxyCompactList}\small\item\em Define a type from the various from$\ast$ function defined in this class. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{classASN1CContainer_aca77386df5f80660d8a72481d96eabe0}{set\+Data} (asn\+\_\+\+T\+Y\+PE $\ast$\hyperlink{classASN1CContainer_a025329e80ae2a3216fc1d1cf6a8f957d}{data})
\begin{DoxyCompactList}\small\item\em Set the underlying data of this object. \end{DoxyCompactList}\item 
bool \hyperlink{classASN1CContainer_a24949d778b5d738c17f80127ab4b188f}{from\+Buf} (const char $\ast$buf, size\+\_\+t size, \hyperlink{classASN1CContainer_a9edaf11eed4f5ded9a32200e43832e72}{asn\+\_\+decode} decode)
\begin{DoxyCompactList}\small\item\em Read the data from a buffer, using the a specified function for decoding. \end{DoxyCompactList}\item 
bool \hyperlink{classASN1CContainer_a90a2a5fbe0601dff3b2ac886f06afd6b}{from\+File} (const char $\ast$filename, \hyperlink{classASN1CContainer_a5830db096eef3cee08cb7e948624aa3c}{from\+Fn} function)
\begin{DoxyCompactList}\small\item\em Read the data from a file, using the a specified function for decoding. \end{DoxyCompactList}\item 
bool \hyperlink{classASN1CContainer_a6fec3867e5aa5893dc497add7f179111}{to\+File} (const char $\ast$filename) const 
\begin{DoxyCompactList}\small\item\em Write the data to a file. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
static int \hyperlink{classASN1CContainer_aa0216c3146bad94b0429fd56da4565f0}{write\+Buf\+To\+Ofstream} (const void $\ast$buffer, size\+\_\+t size, void $\ast$app\+\_\+key)
\begin{DoxyCompactList}\small\item\em Write a buffer to output stream. \end{DoxyCompactList}\item 
static int \hyperlink{classASN1CContainer_a89eaae98d4b34890bc8745bf0f834c8d}{write\+Buf\+To\+Vector} (const void $\ast$buffer, size\+\_\+t size, void $\ast$app\+\_\+key)
\begin{DoxyCompactList}\small\item\em Write a buffer to output vector. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename asn\+\_\+\+T\+Y\+PE$>$\\*
class A\+S\+N1\+C\+Container$<$ asn\+\_\+\+T\+Y\+P\+E $>$}

Container class for a type generated by asn.\+1 C compiler (\href{https://lionet.info/asn1c/blog/}{\tt https\+://lionet.\+info/asn1c/blog/}) 

{\bfseries  What is A\+S\+N.\+1? }

A\+S\+N.\+1 stands for Abstract Syntax Notation One. It allows describing complex data structures independently of any particular programming language. The A\+S\+N.\+1 compiler would take these A\+S\+N.\+1 specifications and produce a set of target language (C, C++, Java) files which would contain the native type definitions for these abstractly specified structures, and also generate a code which would perform the conversions of these structures into/from a series of bytes (serialization/deserialization), (presumably, these routines would be useful if the structure is going to be transferred over the network or written to an external media).

There are multiple data encodings developed for A\+S\+N.\+1. The most widely used ones are B\+ER (Basic Encoding Rules), C\+ER (Canonical-\/), D\+ER (Distinguished Encoding Rules), P\+ER (Packed Encoding Rules) and X\+ER (X\+ML Encoding Rules).

{\bfseries  How Aimsun deal with A\+S\+N.\+1 }

In Aimsun we make use of the B\+SD asn.\+1 C compiler to translate the A\+S\+N.\+1 specification into C++-\/compatible data structures. \hyperlink{classASN1CContainer}{A\+S\+N1\+C\+Container} was born to hide the C-\/functions and structures that follow from this process. This container can be used in junction with Q\+Shared\+Data\+Pointer to implement a Copy-\/\+On-\/\+Write semantic. This class is not meant to be used without a container which abstracts the functionalities provided in the following because these can change in future (we can\textquotesingle{}t predict if the output of the asn.\+1 C compiler will be the same in the future).

For an example of usage, please look to the class \hyperlink{classCAMMessage}{C\+A\+M\+Message}. It is necessary to initialize the class by setting the type definition created by the A\+S\+N.\+1 compiler (set\+Type\+Def), and if a manual modification to the internal data is needed, it is necessary to call the method initialize\+Empty to allocate the internal memory; is not possible to do this initialization in the constructor due to a lack of a custom constructor in the Q\+Shared\+Data\+Pointer class.

{\bfseries  How to write a class which uses a type derived from the A\+S\+N.\+1 compiler }

Let\textquotesingle{}s start with a simple A\+S\+N.\+1 definition\+:


\begin{DoxyCode}
1 MyModule DEFINITIONS ::=
2 BEGIN
3 
4 MyTypes ::= SEQUENCE \{
5   myObjectId OBJECT IDENTIFIER,
6   mySeqOf SEQUENCE OF MyInt,
7   myBitString BIT STRING \{
8                     muxToken(0),
9                     modemToken(1)
10               \}
11 \}
12 
13 MyInt ::= INTEGER (0..65535) END
\end{DoxyCode}


Compiling this definition will generate a lot of files; however, the main type will be a struct My\+Types\+\_\+t. This type is mean to be enclosed in the class \hyperlink{classASN1CContainer}{A\+S\+N1\+C\+Container}\+: 
\begin{DoxyCode}
...
private:
    QSharedDataPointer< ASN1CContainer<MyTypes\_t> > m\_message;
...
\end{DoxyCode}


Let\textquotesingle{}s suppose that the shared pointer m\+\_\+message is a private member of the class called My\+Type\+Message. It is recommended to initialize the variable in the constructors\+: 
\begin{DoxyCode}
\textcolor{preprocessor}{#include "MyTypes.h"} \textcolor{comment}{// Generated by the asn.1 compiler}

MyTypeMessage::MyTypeMessage()
\{
    m\_message = \textcolor{keyword}{new} \hyperlink{classASN1CContainer}{ASN1CContainer<MyTypes\_t>} ();
    m\_message->\hyperlink{classASN1CContainer_a61559655caab168362a30c0538950ba3}{setTypeDef}(&asn\_DEF\_MyTypes);
\}
\end{DoxyCode}
 The object asn\+\_\+\+D\+E\+F\+\_\+\+My\+Types is created automatically by the asn.\+1 compiler, and defined in the main header of the generated files. It is strictly necessary to set the type definition, or the other methods (including the deconstructor and the memory management) will not work.

Giving the C\+OW characteristic of the class, in the deconstructor is not possible to delete the class. The object will be automatically deleted when the internal reference count reaches 0; destroying the pointer, done automatically in the My\+Type\+Message deconstructor, decrements the reference count. 
\begin{DoxyCode}
MyTypeMessage::~MyTypeMessage()
\{
    \textcolor{comment}{// Do not delete m\_message;}
\}
\end{DoxyCode}


The message can now be automatically built from an X\+ML file, a byte stream, or a byte file through the corresponding from$\ast$ functions. For instance\+: 
\begin{DoxyCode}
\textcolor{keywordtype}{bool} MyTypeMessage::FromXML(\textcolor{keyword}{const} \textcolor{keywordtype}{char} *filename)
\{
    \textcolor{keywordflow}{return} m\_message->fromXML(filename);
\}
\end{DoxyCode}


To access the data in a read-\/only way, it is possible to provide to the user a const access to the data contained in the message itself. For writing access, it is possible to provide a non-\/const access. Please note that any non-\/const access to the data, if the reference count of the object is greater than 1, will trigger a deep object copy.


\begin{DoxyCode}
\textcolor{keyword}{const} MyTypes\_t* MyTypeMessage::constData()\textcolor{keyword}{ const}
\textcolor{keyword}{}\{
   \textcolor{keywordflow}{return} m\_message.constData()->constData();
\}

MyTypes\_t* MyTypeMessage::data()
\{
   \textcolor{keywordflow}{return} m\_message.data()->data();
\}
\end{DoxyCode}
 

\subsection{Constructor \& Destructor Documentation}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{A\+S\+N1\+C\+Container()}{ASN1CContainer()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::{\bf A\+S\+N1\+C\+Container} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classASN1CContainer_ad8d69cd8ce21023ea36410113162a008}{}\label{classASN1CContainer_ad8d69cd8ce21023ea36410113162a008}


Creating an empty (and invalid) \hyperlink{classASN1CContainer}{A\+S\+N1\+C\+Container}. 

To validate the object, call set\+Type\+Def. \index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{A\+S\+N1\+C\+Container(const A\+S\+N1\+C\+Container \&other)}{ASN1CContainer(const ASN1CContainer &other)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::{\bf A\+S\+N1\+C\+Container} (
\begin{DoxyParamCaption}
\item[{const {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$ \&}]{other}
\end{DoxyParamCaption}
)}\hypertarget{classASN1CContainer_a0fdf5aaaef51b6b9c1e10442e6e72890}{}\label{classASN1CContainer_a0fdf5aaaef51b6b9c1e10442e6e72890}


Copy another object (deep copy) 


\begin{DoxyParams}{Parameters}
{\em other} & other object \\
\hline
\end{DoxyParams}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!````~A\+S\+N1\+C\+Container@{$\sim$\+A\+S\+N1\+C\+Container}}
\index{````~A\+S\+N1\+C\+Container@{$\sim$\+A\+S\+N1\+C\+Container}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{$\sim$\+A\+S\+N1\+C\+Container()}{~ASN1CContainer()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::$\sim${\bf A\+S\+N1\+C\+Container} (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classASN1CContainer_a26020bb451f75d62ae28bc43568aee17}{}\label{classASN1CContainer_a26020bb451f75d62ae28bc43568aee17}


Deconstructor. 

It calls \hyperlink{classASN1CContainer_a6492cd5793ca9e2ab073445b358a68b5}{clear()} to perform all the required delete operations. 

\subsection{Member Function Documentation}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!clear@{clear}}
\index{clear@{clear}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{clear()}{clear()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ void {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::clear (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classASN1CContainer_a6492cd5793ca9e2ab073445b358a68b5}{}\label{classASN1CContainer_a6492cd5793ca9e2ab073445b358a68b5}


Perform all the required operation to clear the memory. 

This actually delete the underlying data structure. \index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!const\+Data@{const\+Data}}
\index{const\+Data@{const\+Data}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{const\+Data() const }{constData() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ asn\+\_\+\+T\+Y\+PE const $\ast$ {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::const\+Data (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classASN1CContainer_a7db5e6ea01cfc7dc209b73788a034b81}{}\label{classASN1CContainer_a7db5e6ea01cfc7dc209b73788a034b81}


Return a const pointer to the A\+S\+N.\+1 structure, allowing reading. 

It is not possible to edit the structure, thus no deep copy will be triggered.

\begin{DoxyReturn}{Returns}
Pointer to the generated A\+S\+N.\+1 structure 
\end{DoxyReturn}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!data@{data}}
\index{data@{data}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{data()}{data()}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ asn\+\_\+\+T\+Y\+PE $\ast$ {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::data (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\hypertarget{classASN1CContainer_a025329e80ae2a3216fc1d1cf6a8f957d}{}\label{classASN1CContainer_a025329e80ae2a3216fc1d1cf6a8f957d}


Return a pointer to the A\+S\+N.\+1 structure, allowing reading and editing. 

If the internal reference count is greater than 1, it will trigger a deep copy even in case of a read operation.

\begin{DoxyReturn}{Returns}
Pointer to the generated A\+S\+N.\+1 structure 
\end{DoxyReturn}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!from\+B\+ER@{from\+B\+ER}}
\index{from\+B\+ER@{from\+B\+ER}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{from\+B\+E\+R(const char $\ast$buf, size\+\_\+t size)}{fromBER(const char *buf, size_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ bool {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::from\+B\+ER (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{buf, }
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\hypertarget{classASN1CContainer_a08fc60e1d78b99b33a19dba1f1c39900}{}\label{classASN1CContainer_a08fc60e1d78b99b33a19dba1f1c39900}


Read the data structure from binary input. 


\begin{DoxyParams}{Parameters}
{\em buf} & The C buffer (for compatibility with the A\+S\+N.\+1 C functions) \\
\hline
{\em size} & The size of the buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True in case of success 
\end{DoxyReturn}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!from\+B\+ER@{from\+B\+ER}}
\index{from\+B\+ER@{from\+B\+ER}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{from\+B\+E\+R(const std\+::vector$<$ char $>$ \&input)}{fromBER(const std::vector< char > &input)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ bool {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::from\+B\+ER (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ char $>$ \&}]{input}
\end{DoxyParamCaption}
)}\hypertarget{classASN1CContainer_afbeda1aa393679759574f17e34cedf06}{}\label{classASN1CContainer_afbeda1aa393679759574f17e34cedf06}


Read the data structure from binary input. 


\begin{DoxyParams}{Parameters}
{\em input} & The C++ buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True in case of success 
\end{DoxyReturn}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!from\+B\+ER@{from\+B\+ER}}
\index{from\+B\+ER@{from\+B\+ER}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{from\+B\+E\+R(const char $\ast$filename)}{fromBER(const char *filename)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ bool {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::from\+B\+ER (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{filename}
\end{DoxyParamCaption}
)}\hypertarget{classASN1CContainer_a7465eb755c1031b3745796faa02781ad}{}\label{classASN1CContainer_a7465eb755c1031b3745796faa02781ad}


Read the data structure from a binary file. 


\begin{DoxyParams}{Parameters}
{\em filename} & The file name \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True in case of success 
\end{DoxyReturn}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!from\+Buf@{from\+Buf}}
\index{from\+Buf@{from\+Buf}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{from\+Buf(const char $\ast$buf, size\+\_\+t size, asn\+\_\+decode decode)}{fromBuf(const char *buf, size_t size, asn_decode decode)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ bool {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::from\+Buf (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{buf, }
\item[{size\+\_\+t}]{size, }
\item[{{\bf asn\+\_\+decode}}]{decode}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classASN1CContainer_a24949d778b5d738c17f80127ab4b188f}{}\label{classASN1CContainer_a24949d778b5d738c17f80127ab4b188f}


Read the data from a buffer, using the a specified function for decoding. 


\begin{DoxyParams}{Parameters}
{\em buf} & The buffer \\
\hline
{\em size} & The buffer size \\
\hline
{\em decode} & The function to use (xer\+\_\+decode or ber\+\_\+decode) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if success 
\end{DoxyReturn}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!from\+File@{from\+File}}
\index{from\+File@{from\+File}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{from\+File(const char $\ast$filename, from\+Fn function)}{fromFile(const char *filename, fromFn function)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ bool {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::from\+File (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{filename, }
\item[{{\bf from\+Fn}}]{function}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classASN1CContainer_a90a2a5fbe0601dff3b2ac886f06afd6b}{}\label{classASN1CContainer_a90a2a5fbe0601dff3b2ac886f06afd6b}


Read the data from a file, using the a specified function for decoding. 


\begin{DoxyParams}{Parameters}
{\em filename} & The filename \\
\hline
{\em function} & The function to use (from\+X\+ML or from\+B\+ER) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if success 
\end{DoxyReturn}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!from\+X\+ML@{from\+X\+ML}}
\index{from\+X\+ML@{from\+X\+ML}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{from\+X\+M\+L(const char $\ast$buf, size\+\_\+t size)}{fromXML(const char *buf, size_t size)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ bool {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::from\+X\+ML (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{buf, }
\item[{size\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\hypertarget{classASN1CContainer_aac98fb872b823dfaffce36a8bf24ddbe}{}\label{classASN1CContainer_aac98fb872b823dfaffce36a8bf24ddbe}


Read the data structure from X\+ML input. 


\begin{DoxyParams}{Parameters}
{\em buf} & The C buffer (for compatibility with the A\+S\+N.\+1 C functions) \\
\hline
{\em size} & The size of the buffer \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True in case of success 
\end{DoxyReturn}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!from\+X\+ML@{from\+X\+ML}}
\index{from\+X\+ML@{from\+X\+ML}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{from\+X\+M\+L(const char $\ast$filename)}{fromXML(const char *filename)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ bool {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::from\+X\+ML (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{filename}
\end{DoxyParamCaption}
)}\hypertarget{classASN1CContainer_af43531162a367d3b79be39e90ec72ebb}{}\label{classASN1CContainer_af43531162a367d3b79be39e90ec72ebb}


Read the data structure from an X\+ML file. 


\begin{DoxyParams}{Parameters}
{\em filename} & The file name \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True in case of success 
\end{DoxyReturn}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!has\+Data@{has\+Data}}
\index{has\+Data@{has\+Data}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{has\+Data() const }{hasData() const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ bool {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::has\+Data (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\hypertarget{classASN1CContainer_a67a086c665ecbf7a54e390c8fb7df47f}{}\label{classASN1CContainer_a67a086c665ecbf7a54e390c8fb7df47f}


Check if the underlying data is valid. 

\begin{DoxyReturn}{Returns}
True if the data is some valid object 
\end{DoxyReturn}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!set\+Data@{set\+Data}}
\index{set\+Data@{set\+Data}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{set\+Data(asn\+\_\+\+T\+Y\+P\+E $\ast$data)}{setData(asn_TYPE *data)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ void {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::set\+Data (
\begin{DoxyParamCaption}
\item[{asn\+\_\+\+T\+Y\+PE $\ast$}]{data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classASN1CContainer_aca77386df5f80660d8a72481d96eabe0}{}\label{classASN1CContainer_aca77386df5f80660d8a72481d96eabe0}


Set the underlying data of this object. 


\begin{DoxyParams}{Parameters}
{\em data} & A pointer to the real data \\
\hline
\end{DoxyParams}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!set\+Type\+Def@{set\+Type\+Def}}
\index{set\+Type\+Def@{set\+Type\+Def}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{set\+Type\+Def(asn\+\_\+\+T\+Y\+P\+E\+\_\+descriptor\+\_\+s $\ast$asn\+Def)}{setTypeDef(asn_TYPE_descriptor_s *asnDef)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ void {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::set\+Type\+Def (
\begin{DoxyParamCaption}
\item[{{\bf asn\+\_\+\+T\+Y\+P\+E\+\_\+descriptor\+\_\+s} $\ast$}]{asn\+Def}
\end{DoxyParamCaption}
)}\hypertarget{classASN1CContainer_a61559655caab168362a30c0538950ba3}{}\label{classASN1CContainer_a61559655caab168362a30c0538950ba3}


Set the type definition. 

The type definition is provided in the generated C files. It is not possible to embed it in the constructor because the Q\+Shared\+Data construct does not take any external argument rather than the pointer itself.


\begin{DoxyParams}{Parameters}
{\em asn\+Def} & the generated definition \\
\hline
\end{DoxyParams}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!to\+D\+ER@{to\+D\+ER}}
\index{to\+D\+ER@{to\+D\+ER}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{to\+D\+E\+R(std\+::vector$<$ char $>$ $\ast$output) const }{toDER(std::vector< char > *output) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ bool {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::to\+D\+ER (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ char $>$ $\ast$}]{output}
\end{DoxyParamCaption}
) const}\hypertarget{classASN1CContainer_af84be317f31518978a63621b4fc67c40}{}\label{classASN1CContainer_af84be317f31518978a63621b4fc67c40}


Write the data structure to a binary output. 


\begin{DoxyParams}{Parameters}
{\em output} & The output vector \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True in case of success 
\end{DoxyReturn}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!to\+D\+ER@{to\+D\+ER}}
\index{to\+D\+ER@{to\+D\+ER}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{to\+D\+E\+R(const char $\ast$filename) const }{toDER(const char *filename) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ bool {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::to\+D\+ER (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{filename}
\end{DoxyParamCaption}
) const}\hypertarget{classASN1CContainer_ae3fa0fbad6b0375b36a73be41f2e8075}{}\label{classASN1CContainer_ae3fa0fbad6b0375b36a73be41f2e8075}


Write the data structure to a binary file. 


\begin{DoxyParams}{Parameters}
{\em filename} & The file name \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True in case of success 
\end{DoxyReturn}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!to\+File@{to\+File}}
\index{to\+File@{to\+File}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{to\+File(const char $\ast$filename) const }{toFile(const char *filename) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE$>$ bool {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::to\+File (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{filename}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}}\hypertarget{classASN1CContainer_a6fec3867e5aa5893dc497add7f179111}{}\label{classASN1CContainer_a6fec3867e5aa5893dc497add7f179111}


Write the data to a file. 


\begin{DoxyParams}{Parameters}
{\em filename} & The filename \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True if success 
\end{DoxyReturn}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!to\+X\+ML@{to\+X\+ML}}
\index{to\+X\+ML@{to\+X\+ML}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{to\+X\+M\+L(std\+::ostream $\ast$output) const }{toXML(std::ostream *output) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ bool {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::to\+X\+ML (
\begin{DoxyParamCaption}
\item[{std\+::ostream $\ast$}]{output}
\end{DoxyParamCaption}
) const}\hypertarget{classASN1CContainer_ae444a9554d1a856d74a942f70a3b2fb8}{}\label{classASN1CContainer_ae444a9554d1a856d74a942f70a3b2fb8}


Write the data structure to a X\+ML output. 


\begin{DoxyParams}{Parameters}
{\em output} & The output \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True in case of success 
\end{DoxyReturn}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!to\+X\+ML@{to\+X\+ML}}
\index{to\+X\+ML@{to\+X\+ML}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{to\+X\+M\+L(const char $\ast$filename) const }{toXML(const char *filename) const }}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ bool {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::to\+X\+ML (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{filename}
\end{DoxyParamCaption}
) const}\hypertarget{classASN1CContainer_a165c57c9a77d80d5f8cd6c2d6b902650}{}\label{classASN1CContainer_a165c57c9a77d80d5f8cd6c2d6b902650}


Write the data structure to a X\+ML file. 


\begin{DoxyParams}{Parameters}
{\em filename} & The file name \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
True in case of success 
\end{DoxyReturn}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!write\+Buf\+To\+Ofstream@{write\+Buf\+To\+Ofstream}}
\index{write\+Buf\+To\+Ofstream@{write\+Buf\+To\+Ofstream}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{write\+Buf\+To\+Ofstream(const void $\ast$buffer, size\+\_\+t size, void $\ast$app\+\_\+key)}{writeBufToOfstream(const void *buffer, size_t size, void *app_key)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ int {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::write\+Buf\+To\+Ofstream (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{buffer, }
\item[{size\+\_\+t}]{size, }
\item[{void $\ast$}]{app\+\_\+key}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}}\hypertarget{classASN1CContainer_aa0216c3146bad94b0429fd56da4565f0}{}\label{classASN1CContainer_aa0216c3146bad94b0429fd56da4565f0}


Write a buffer to output stream. 

To be used in the C compiler functions


\begin{DoxyParams}{Parameters}
{\em buffer} & The buffer (const char $\ast$buf almost in all cases) \\
\hline
{\em size} & The size of the buffer \\
\hline
{\em app\+\_\+key} & The structure to write into (std\+::ostream $\ast$) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if success 
\end{DoxyReturn}
\index{A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}!write\+Buf\+To\+Vector@{write\+Buf\+To\+Vector}}
\index{write\+Buf\+To\+Vector@{write\+Buf\+To\+Vector}!A\+S\+N1\+C\+Container@{A\+S\+N1\+C\+Container}}
\subsubsection[{\texorpdfstring{write\+Buf\+To\+Vector(const void $\ast$buffer, size\+\_\+t size, void $\ast$app\+\_\+key)}{writeBufToVector(const void *buffer, size_t size, void *app_key)}}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename asn\+\_\+\+T\+Y\+PE $>$ int {\bf A\+S\+N1\+C\+Container}$<$ asn\+\_\+\+T\+Y\+PE $>$\+::write\+Buf\+To\+Vector (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{buffer, }
\item[{size\+\_\+t}]{size, }
\item[{void $\ast$}]{app\+\_\+key}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [protected]}}\hypertarget{classASN1CContainer_a89eaae98d4b34890bc8745bf0f834c8d}{}\label{classASN1CContainer_a89eaae98d4b34890bc8745bf0f834c8d}


Write a buffer to output vector. 

To be used in the C compiler functions


\begin{DoxyParams}{Parameters}
{\em buffer} & The buffer (const char $\ast$buf almost in all cases) \\
\hline
{\em size} & The size of the buffer \\
\hline
{\em app\+\_\+key} & The structure to write into (std\+::vector$<$char$>$ $\ast$) \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
0 if success 
\end{DoxyReturn}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
include/aimsun\+\_\+extensions/\+V2\+X\+Framework/Asn1c\+Container.\+h\end{DoxyCompactItemize}
