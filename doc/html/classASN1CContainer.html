<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Flourish V2X plugin: ASN1CContainer&lt; asn_TYPE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Flourish V2X plugin
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Vehicular-to-X simulation framework for the Flourish project</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="classASN1CContainer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ASN1CContainer&lt; asn_TYPE &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__V2XFramework.html">V2X Framework for Aimsun</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Container class for a type generated by asn.1 C compiler (<a href="https://lionet.info/asn1c/blog/">https://lionet.info/asn1c/blog/</a>)  
 <a href="classASN1CContainer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Asn1cContainer_8h_source.html">Asn1cContainer.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ASN1CContainer&lt; asn_TYPE &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classASN1CContainer__inherit__graph.png" border="0" usemap="#ASN1CContainer_3_01asn__TYPE_01_4_inherit__map" alt="Inheritance graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for ASN1CContainer&lt; asn_TYPE &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classASN1CContainer__coll__graph.png" border="0" usemap="#ASN1CContainer_3_01asn__TYPE_01_4_coll__map" alt="Collaboration graph"/></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad8d69cd8ce21023ea36410113162a008"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#ad8d69cd8ce21023ea36410113162a008">ASN1CContainer</a> ()</td></tr>
<tr class="memdesc:ad8d69cd8ce21023ea36410113162a008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creating an empty (and invalid) <a class="el" href="classASN1CContainer.html" title="Container class for a type generated by asn.1 C compiler (https://lionet.info/asn1c/blog/) ...">ASN1CContainer</a>.  <a href="#ad8d69cd8ce21023ea36410113162a008">More...</a><br /></td></tr>
<tr class="separator:ad8d69cd8ce21023ea36410113162a008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fdf5aaaef51b6b9c1e10442e6e72890"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#a0fdf5aaaef51b6b9c1e10442e6e72890">ASN1CContainer</a> (const <a class="el" href="classASN1CContainer.html">ASN1CContainer</a> &amp;other)</td></tr>
<tr class="memdesc:a0fdf5aaaef51b6b9c1e10442e6e72890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy another object (deep copy)  <a href="#a0fdf5aaaef51b6b9c1e10442e6e72890">More...</a><br /></td></tr>
<tr class="separator:a0fdf5aaaef51b6b9c1e10442e6e72890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26020bb451f75d62ae28bc43568aee17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#a26020bb451f75d62ae28bc43568aee17">~ASN1CContainer</a> ()</td></tr>
<tr class="memdesc:a26020bb451f75d62ae28bc43568aee17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deconstructor.  <a href="#a26020bb451f75d62ae28bc43568aee17">More...</a><br /></td></tr>
<tr class="separator:a26020bb451f75d62ae28bc43568aee17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a025329e80ae2a3216fc1d1cf6a8f957d"><td class="memItemLeft" align="right" valign="top">asn_TYPE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#a025329e80ae2a3216fc1d1cf6a8f957d">data</a> ()</td></tr>
<tr class="memdesc:a025329e80ae2a3216fc1d1cf6a8f957d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the ASN.1 structure, allowing reading and editing.  <a href="#a025329e80ae2a3216fc1d1cf6a8f957d">More...</a><br /></td></tr>
<tr class="separator:a025329e80ae2a3216fc1d1cf6a8f957d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db5e6ea01cfc7dc209b73788a034b81"><td class="memItemLeft" align="right" valign="top">asn_TYPE const *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#a7db5e6ea01cfc7dc209b73788a034b81">constData</a> () const </td></tr>
<tr class="memdesc:a7db5e6ea01cfc7dc209b73788a034b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const pointer to the ASN.1 structure, allowing reading.  <a href="#a7db5e6ea01cfc7dc209b73788a034b81">More...</a><br /></td></tr>
<tr class="separator:a7db5e6ea01cfc7dc209b73788a034b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c7691789087f204c37207590eaaf89d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7c7691789087f204c37207590eaaf89d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#a7c7691789087f204c37207590eaaf89d">initializeEmpty</a> ()</td></tr>
<tr class="memdesc:a7c7691789087f204c37207590eaaf89d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate the memory for a manual editing of the message. <br /></td></tr>
<tr class="separator:a7c7691789087f204c37207590eaaf89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a086c665ecbf7a54e390c8fb7df47f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#a67a086c665ecbf7a54e390c8fb7df47f">hasData</a> () const </td></tr>
<tr class="memdesc:a67a086c665ecbf7a54e390c8fb7df47f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the underlying data is valid.  <a href="#a67a086c665ecbf7a54e390c8fb7df47f">More...</a><br /></td></tr>
<tr class="separator:a67a086c665ecbf7a54e390c8fb7df47f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61559655caab168362a30c0538950ba3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#a61559655caab168362a30c0538950ba3">setTypeDef</a> (<a class="el" href="structasn__TYPE__descriptor__s.html">asn_TYPE_descriptor_s</a> *asnDef)</td></tr>
<tr class="memdesc:a61559655caab168362a30c0538950ba3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the type definition.  <a href="#a61559655caab168362a30c0538950ba3">More...</a><br /></td></tr>
<tr class="separator:a61559655caab168362a30c0538950ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6492cd5793ca9e2ab073445b358a68b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#a6492cd5793ca9e2ab073445b358a68b5">clear</a> ()</td></tr>
<tr class="memdesc:a6492cd5793ca9e2ab073445b358a68b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform all the required operation to clear the memory.  <a href="#a6492cd5793ca9e2ab073445b358a68b5">More...</a><br /></td></tr>
<tr class="separator:a6492cd5793ca9e2ab073445b358a68b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae444a9554d1a856d74a942f70a3b2fb8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#ae444a9554d1a856d74a942f70a3b2fb8">toXML</a> (std::ostream *output) const </td></tr>
<tr class="memdesc:ae444a9554d1a856d74a942f70a3b2fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data structure to a XML output.  <a href="#ae444a9554d1a856d74a942f70a3b2fb8">More...</a><br /></td></tr>
<tr class="separator:ae444a9554d1a856d74a942f70a3b2fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165c57c9a77d80d5f8cd6c2d6b902650"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#a165c57c9a77d80d5f8cd6c2d6b902650">toXML</a> (const char *filename) const </td></tr>
<tr class="memdesc:a165c57c9a77d80d5f8cd6c2d6b902650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data structure to a XML file.  <a href="#a165c57c9a77d80d5f8cd6c2d6b902650">More...</a><br /></td></tr>
<tr class="separator:a165c57c9a77d80d5f8cd6c2d6b902650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84be317f31518978a63621b4fc67c40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#af84be317f31518978a63621b4fc67c40">toDER</a> (std::vector&lt; char &gt; *output) const </td></tr>
<tr class="memdesc:af84be317f31518978a63621b4fc67c40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data structure to a binary output.  <a href="#af84be317f31518978a63621b4fc67c40">More...</a><br /></td></tr>
<tr class="separator:af84be317f31518978a63621b4fc67c40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3fa0fbad6b0375b36a73be41f2e8075"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#ae3fa0fbad6b0375b36a73be41f2e8075">toDER</a> (const char *filename) const </td></tr>
<tr class="memdesc:ae3fa0fbad6b0375b36a73be41f2e8075"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data structure to a binary file.  <a href="#ae3fa0fbad6b0375b36a73be41f2e8075">More...</a><br /></td></tr>
<tr class="separator:ae3fa0fbad6b0375b36a73be41f2e8075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac98fb872b823dfaffce36a8bf24ddbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#aac98fb872b823dfaffce36a8bf24ddbe">fromXML</a> (const char *buf, size_t size)</td></tr>
<tr class="memdesc:aac98fb872b823dfaffce36a8bf24ddbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data structure from XML input.  <a href="#aac98fb872b823dfaffce36a8bf24ddbe">More...</a><br /></td></tr>
<tr class="separator:aac98fb872b823dfaffce36a8bf24ddbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43531162a367d3b79be39e90ec72ebb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#af43531162a367d3b79be39e90ec72ebb">fromXML</a> (const char *filename)</td></tr>
<tr class="memdesc:af43531162a367d3b79be39e90ec72ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data structure from an XML file.  <a href="#af43531162a367d3b79be39e90ec72ebb">More...</a><br /></td></tr>
<tr class="separator:af43531162a367d3b79be39e90ec72ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fc60e1d78b99b33a19dba1f1c39900"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#a08fc60e1d78b99b33a19dba1f1c39900">fromBER</a> (const char *buf, size_t size)</td></tr>
<tr class="memdesc:a08fc60e1d78b99b33a19dba1f1c39900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data structure from binary input.  <a href="#a08fc60e1d78b99b33a19dba1f1c39900">More...</a><br /></td></tr>
<tr class="separator:a08fc60e1d78b99b33a19dba1f1c39900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbeda1aa393679759574f17e34cedf06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#afbeda1aa393679759574f17e34cedf06">fromBER</a> (const std::vector&lt; char &gt; &amp;input)</td></tr>
<tr class="memdesc:afbeda1aa393679759574f17e34cedf06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data structure from binary input.  <a href="#afbeda1aa393679759574f17e34cedf06">More...</a><br /></td></tr>
<tr class="separator:afbeda1aa393679759574f17e34cedf06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7465eb755c1031b3745796faa02781ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#a7465eb755c1031b3745796faa02781ad">fromBER</a> (const char *filename)</td></tr>
<tr class="memdesc:a7465eb755c1031b3745796faa02781ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data structure from a binary file.  <a href="#a7465eb755c1031b3745796faa02781ad">More...</a><br /></td></tr>
<tr class="separator:a7465eb755c1031b3745796faa02781ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5d252d15af64426472504f04f2b1e8"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acc5d252d15af64426472504f04f2b1e8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#acc5d252d15af64426472504f04f2b1e8">toConsole</a> () const </td></tr>
<tr class="memdesc:acc5d252d15af64426472504f04f2b1e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the data to std::cout. <br /></td></tr>
<tr class="separator:acc5d252d15af64426472504f04f2b1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a9edaf11eed4f5ded9a32200e43832e72"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9edaf11eed4f5ded9a32200e43832e72"></a>
typedef <a class="el" href="structasn__dec__rval__s.html">asn_dec_rval_t</a>(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#a9edaf11eed4f5ded9a32200e43832e72">asn_decode</a>) (struct <a class="el" href="structasn__codec__ctx__s.html">asn_codec_ctx_s</a> *, struct <a class="el" href="structasn__TYPE__descriptor__s.html">asn_TYPE_descriptor_s</a> *, void **, const void *, size_t)</td></tr>
<tr class="memdesc:a9edaf11eed4f5ded9a32200e43832e72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a type for the decode functions provided by the C compiler. <br /></td></tr>
<tr class="separator:a9edaf11eed4f5ded9a32200e43832e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5830db096eef3cee08cb7e948624aa3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5830db096eef3cee08cb7e948624aa3c"></a>
typedef bool(<a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#a5830db096eef3cee08cb7e948624aa3c">fromFn</a>) (const char *buf, size_t size)</td></tr>
<tr class="memdesc:a5830db096eef3cee08cb7e948624aa3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a type from the various from* function defined in this class. <br /></td></tr>
<tr class="separator:a5830db096eef3cee08cb7e948624aa3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aca77386df5f80660d8a72481d96eabe0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#aca77386df5f80660d8a72481d96eabe0">setData</a> (asn_TYPE *<a class="el" href="classASN1CContainer.html#a025329e80ae2a3216fc1d1cf6a8f957d">data</a>)</td></tr>
<tr class="memdesc:aca77386df5f80660d8a72481d96eabe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the underlying data of this object.  <a href="#aca77386df5f80660d8a72481d96eabe0">More...</a><br /></td></tr>
<tr class="separator:aca77386df5f80660d8a72481d96eabe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24949d778b5d738c17f80127ab4b188f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#a24949d778b5d738c17f80127ab4b188f">fromBuf</a> (const char *buf, size_t size, <a class="el" href="classASN1CContainer.html#a9edaf11eed4f5ded9a32200e43832e72">asn_decode</a> decode)</td></tr>
<tr class="memdesc:a24949d778b5d738c17f80127ab4b188f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from a buffer, using the a specified function for decoding.  <a href="#a24949d778b5d738c17f80127ab4b188f">More...</a><br /></td></tr>
<tr class="separator:a24949d778b5d738c17f80127ab4b188f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a2a5fbe0601dff3b2ac886f06afd6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#a90a2a5fbe0601dff3b2ac886f06afd6b">fromFile</a> (const char *filename, <a class="el" href="classASN1CContainer.html#a5830db096eef3cee08cb7e948624aa3c">fromFn</a> function)</td></tr>
<tr class="memdesc:a90a2a5fbe0601dff3b2ac886f06afd6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the data from a file, using the a specified function for decoding.  <a href="#a90a2a5fbe0601dff3b2ac886f06afd6b">More...</a><br /></td></tr>
<tr class="separator:a90a2a5fbe0601dff3b2ac886f06afd6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fec3867e5aa5893dc497add7f179111"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#a6fec3867e5aa5893dc497add7f179111">toFile</a> (const char *filename) const </td></tr>
<tr class="memdesc:a6fec3867e5aa5893dc497add7f179111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the data to a file.  <a href="#a6fec3867e5aa5893dc497add7f179111">More...</a><br /></td></tr>
<tr class="separator:a6fec3867e5aa5893dc497add7f179111"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:aa0216c3146bad94b0429fd56da4565f0"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#aa0216c3146bad94b0429fd56da4565f0">writeBufToOfstream</a> (const void *buffer, size_t size, void *app_key)</td></tr>
<tr class="memdesc:aa0216c3146bad94b0429fd56da4565f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a buffer to output stream.  <a href="#aa0216c3146bad94b0429fd56da4565f0">More...</a><br /></td></tr>
<tr class="separator:aa0216c3146bad94b0429fd56da4565f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89eaae98d4b34890bc8745bf0f834c8d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classASN1CContainer.html#a89eaae98d4b34890bc8745bf0f834c8d">writeBufToVector</a> (const void *buffer, size_t size, void *app_key)</td></tr>
<tr class="memdesc:a89eaae98d4b34890bc8745bf0f834c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a buffer to output vector.  <a href="#a89eaae98d4b34890bc8745bf0f834c8d">More...</a><br /></td></tr>
<tr class="separator:a89eaae98d4b34890bc8745bf0f834c8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename asn_TYPE&gt;<br />
class ASN1CContainer&lt; asn_TYPE &gt;</h3>

<p>Container class for a type generated by asn.1 C compiler (<a href="https://lionet.info/asn1c/blog/">https://lionet.info/asn1c/blog/</a>) </p>
<p><b> What is ASN.1? </b></p>
<p>ASN.1 stands for Abstract Syntax Notation One. It allows describing complex data structures independently of any particular programming language. The ASN.1 compiler would take these ASN.1 specifications and produce a set of target language (C, C++, Java) files which would contain the native type definitions for these abstractly specified structures, and also generate a code which would perform the conversions of these structures into/from a series of bytes (serialization/deserialization), (presumably, these routines would be useful if the structure is going to be transferred over the network or written to an external media).</p>
<p>There are multiple data encodings developed for ASN.1. The most widely used ones are BER (Basic Encoding Rules), CER (Canonical-), DER (Distinguished Encoding Rules), PER (Packed Encoding Rules) and XER (XML Encoding Rules).</p>
<p><b> How Aimsun deal with ASN.1 </b></p>
<p>In Aimsun we make use of the BSD asn.1 C compiler to translate the ASN.1 specification into C++-compatible data structures. <a class="el" href="classASN1CContainer.html" title="Container class for a type generated by asn.1 C compiler (https://lionet.info/asn1c/blog/) ...">ASN1CContainer</a> was born to hide the C-functions and structures that follow from this process. This container can be used in junction with QSharedDataPointer to implement a Copy-On-Write semantic. This class is not meant to be used without a container which abstracts the functionalities provided in the following because these can change in future (we can't predict if the output of the asn.1 C compiler will be the same in the future).</p>
<p>For an example of usage, please look to the class <a class="el" href="classCAMMessage.html" title="A CAM message. ">CAMMessage</a>. It is necessary to initialize the class by setting the type definition created by the ASN.1 compiler (setTypeDef), and if a manual modification to the internal data is needed, it is necessary to call the method initializeEmpty to allocate the internal memory; is not possible to do this initialization in the constructor due to a lack of a custom constructor in the QSharedDataPointer class.</p>
<p><b> How to write a class which uses a type derived from the ASN.1 compiler </b></p>
<p>Let's start with a simple ASN.1 definition:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;MyModule DEFINITIONS ::=</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;BEGIN</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;MyTypes ::= SEQUENCE {</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;  myObjectId OBJECT IDENTIFIER,</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;  mySeqOf SEQUENCE OF MyInt,</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;  myBitString BIT STRING {</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;                    muxToken(0),</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;                    modemToken(1)</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;              }</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;}</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;MyInt ::= INTEGER (0..65535) END</div></div><!-- fragment --><p>Compiling this definition will generate a lot of files; however, the main type will be a struct MyTypes_t. This type is mean to be enclosed in the class <a class="el" href="classASN1CContainer.html" title="Container class for a type generated by asn.1 C compiler (https://lionet.info/asn1c/blog/) ...">ASN1CContainer</a>: </p><div class="fragment"><div class="line">...</div><div class="line">private:</div><div class="line">    QSharedDataPointer&lt; ASN1CContainer&lt;MyTypes_t&gt; &gt; m_message;</div><div class="line">...</div></div><!-- fragment --><p>Let's suppose that the shared pointer m_message is a private member of the class called MyTypeMessage. It is recommended to initialize the variable in the constructors: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;MyTypes.h&quot;</span> <span class="comment">// Generated by the asn.1 compiler</span></div><div class="line"></div><div class="line">MyTypeMessage::MyTypeMessage()</div><div class="line">{</div><div class="line">    m_message = <span class="keyword">new</span> <a class="code" href="classASN1CContainer.html">ASN1CContainer&lt;MyTypes_t&gt;</a> ();</div><div class="line">    m_message-&gt;<a class="code" href="classASN1CContainer.html#a61559655caab168362a30c0538950ba3">setTypeDef</a>(&amp;asn_DEF_MyTypes);</div><div class="line">}</div></div><!-- fragment --><p> The object asn_DEF_MyTypes is created automatically by the asn.1 compiler, and defined in the main header of the generated files. It is strictly necessary to set the type definition, or the other methods (including the deconstructor and the memory management) will not work.</p>
<p>Giving the COW characteristic of the class, in the deconstructor is not possible to delete the class. The object will be automatically deleted when the internal reference count reaches 0; destroying the pointer, done automatically in the MyTypeMessage deconstructor, decrements the reference count. </p><div class="fragment"><div class="line">MyTypeMessage::~MyTypeMessage()</div><div class="line">{</div><div class="line">    <span class="comment">// Do not delete m_message;</span></div><div class="line">}</div></div><!-- fragment --><p>The message can now be automatically built from an XML file, a byte stream, or a byte file through the corresponding from* functions. For instance: </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> MyTypeMessage::FromXML(<span class="keyword">const</span> <span class="keywordtype">char</span> *filename)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> m_message-&gt;fromXML(filename);</div><div class="line">}</div></div><!-- fragment --><p>To access the data in a read-only way, it is possible to provide to the user a const access to the data contained in the message itself. For writing access, it is possible to provide a non-const access. Please note that any non-const access to the data, if the reference count of the object is greater than 1, will trigger a deep object copy.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> MyTypes_t* MyTypeMessage::constData()<span class="keyword"> const</span></div><div class="line"><span class="keyword"></span>{</div><div class="line">   <span class="keywordflow">return</span> m_message.constData()-&gt;constData();</div><div class="line">}</div><div class="line"></div><div class="line">MyTypes_t* MyTypeMessage::data()</div><div class="line">{</div><div class="line">   <span class="keywordflow">return</span> m_message.data()-&gt;data();</div><div class="line">}</div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad8d69cd8ce21023ea36410113162a008"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::<a class="el" href="classASN1CContainer.html">ASN1CContainer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creating an empty (and invalid) <a class="el" href="classASN1CContainer.html" title="Container class for a type generated by asn.1 C compiler (https://lionet.info/asn1c/blog/) ...">ASN1CContainer</a>. </p>
<p>To validate the object, call setTypeDef. </p>

</div>
</div>
<a class="anchor" id="a0fdf5aaaef51b6b9c1e10442e6e72890"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::<a class="el" href="classASN1CContainer.html">ASN1CContainer</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy another object (deep copy) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>other object </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a26020bb451f75d62ae28bc43568aee17"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::~<a class="el" href="classASN1CContainer.html">ASN1CContainer</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deconstructor. </p>
<p>It calls <a class="el" href="classASN1CContainer.html#a6492cd5793ca9e2ab073445b358a68b5" title="Perform all the required operation to clear the memory. ">clear()</a> to perform all the required delete operations. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a6492cd5793ca9e2ab073445b358a68b5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Perform all the required operation to clear the memory. </p>
<p>This actually delete the underlying data structure. </p>

</div>
</div>
<a class="anchor" id="a7db5e6ea01cfc7dc209b73788a034b81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asn_TYPE const * <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::constData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a const pointer to the ASN.1 structure, allowing reading. </p>
<p>It is not possible to edit the structure, thus no deep copy will be triggered.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the generated ASN.1 structure </dd></dl>

</div>
</div>
<a class="anchor" id="a025329e80ae2a3216fc1d1cf6a8f957d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">asn_TYPE * <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the ASN.1 structure, allowing reading and editing. </p>
<p>If the internal reference count is greater than 1, it will trigger a deep copy even in case of a read operation.</p>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the generated ASN.1 structure </dd></dl>

</div>
</div>
<a class="anchor" id="a08fc60e1d78b99b33a19dba1f1c39900"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::fromBER </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the data structure from binary input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The C buffer (for compatibility with the ASN.1 C functions) </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success </dd></dl>

</div>
</div>
<a class="anchor" id="afbeda1aa393679759574f17e34cedf06"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::fromBER </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the data structure from binary input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The C++ buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success </dd></dl>

</div>
</div>
<a class="anchor" id="a7465eb755c1031b3745796faa02781ad"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::fromBER </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the data structure from a binary file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success </dd></dl>

</div>
</div>
<a class="anchor" id="a24949d778b5d738c17f80127ab4b188f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::fromBuf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classASN1CContainer.html#a9edaf11eed4f5ded9a32200e43832e72">asn_decode</a>&#160;</td>
          <td class="paramname"><em>decode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data from a buffer, using the a specified function for decoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The buffer </td></tr>
    <tr><td class="paramname">size</td><td>The buffer size </td></tr>
    <tr><td class="paramname">decode</td><td>The function to use (xer_decode or ber_decode) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success </dd></dl>

</div>
</div>
<a class="anchor" id="a90a2a5fbe0601dff3b2ac886f06afd6b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::fromFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classASN1CContainer.html#a5830db096eef3cee08cb7e948624aa3c">fromFn</a>&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read the data from a file, using the a specified function for decoding. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename </td></tr>
    <tr><td class="paramname">function</td><td>The function to use (fromXML or fromBER) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success </dd></dl>

</div>
</div>
<a class="anchor" id="aac98fb872b823dfaffce36a8bf24ddbe"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::fromXML </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the data structure from XML input. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buf</td><td>The C buffer (for compatibility with the ASN.1 C functions) </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success </dd></dl>

</div>
</div>
<a class="anchor" id="af43531162a367d3b79be39e90ec72ebb"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::fromXML </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the data structure from an XML file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success </dd></dl>

</div>
</div>
<a class="anchor" id="a67a086c665ecbf7a54e390c8fb7df47f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::hasData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the underlying data is valid. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the data is some valid object </dd></dl>

</div>
</div>
<a class="anchor" id="aca77386df5f80660d8a72481d96eabe0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::setData </td>
          <td>(</td>
          <td class="paramtype">asn_TYPE *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the underlying data of this object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the real data </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a61559655caab168362a30c0538950ba3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::setTypeDef </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structasn__TYPE__descriptor__s.html">asn_TYPE_descriptor_s</a> *&#160;</td>
          <td class="paramname"><em>asnDef</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the type definition. </p>
<p>The type definition is provided in the generated C files. It is not possible to embed it in the constructor because the QSharedData construct does not take any external argument rather than the pointer itself.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">asnDef</td><td>the generated definition </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af84be317f31518978a63621b4fc67c40"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::toDER </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; char &gt; *&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the data structure to a binary output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The output vector </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success </dd></dl>

</div>
</div>
<a class="anchor" id="ae3fa0fbad6b0375b36a73be41f2e8075"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::toDER </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the data structure to a binary file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success </dd></dl>

</div>
</div>
<a class="anchor" id="a6fec3867e5aa5893dc497add7f179111"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::toFile </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the data to a file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The filename </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if success </dd></dl>

</div>
</div>
<a class="anchor" id="ae444a9554d1a856d74a942f70a3b2fb8"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::toXML </td>
          <td>(</td>
          <td class="paramtype">std::ostream *&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the data structure to a XML output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">output</td><td>The output </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success </dd></dl>

</div>
</div>
<a class="anchor" id="a165c57c9a77d80d5f8cd6c2d6b902650"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::toXML </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the data structure to a XML file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The file name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True in case of success </dd></dl>

</div>
</div>
<a class="anchor" id="aa0216c3146bad94b0429fd56da4565f0"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::writeBufToOfstream </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>app_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a buffer to output stream. </p>
<p>To be used in the C compiler functions</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer (const char *buf almost in all cases) </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer </td></tr>
    <tr><td class="paramname">app_key</td><td>The structure to write into (std::ostream *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success </dd></dl>

</div>
</div>
<a class="anchor" id="a89eaae98d4b34890bc8745bf0f834c8d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename asn_TYPE &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classASN1CContainer.html">ASN1CContainer</a>&lt; asn_TYPE &gt;::writeBufToVector </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>app_key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write a buffer to output vector. </p>
<p>To be used in the C compiler functions</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>The buffer (const char *buf almost in all cases) </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer </td></tr>
    <tr><td class="paramname">app_key</td><td>The structure to write into (std::vector&lt;char&gt; *) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 if success </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/aimsun_extensions/V2XFramework/<a class="el" href="Asn1cContainer_8h_source.html">Asn1cContainer.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
